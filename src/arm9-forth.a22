data_stack_top = (dtcm_loc + 0x2000)

word_length_mask = 0x1F
word_length_bits = 5
word_hidden_flag = 0x20
word_immediate_flag = 0x80

; dsForth is subroutine-threaded

; r0:	Scratch
; r1:	Scratch
; r2:	Scratch
; r3:	Scratch
; r4:	Callee save
; r5:	Callee save
; r6:	Callee save
; r7:	Callee save
; r8:	Data Stack Pointer
; r9:	Top Data Stack Value
; r10:	Constant 0x04000000
; r11:	?
; r12:	Scratch(?)
; r13:	Return Stack Pointer
; r14:	Link Register
; r15:	Program Counter

start_forth:
	ldr	r8, =data_stack_top ; Set the data stack pointer

@@interp_loop:
	bl	LIT
	dd	10 ; newline
	bl	EMIT

	bl	WORD
	bl	OVER ; word ptr
	bl	OVER ; word len
	bl	FIND
	cmp	r9, 0
	beq	@@not_in_dict

	bl	NIP ; word ptr
	bl	NIP ; word len
	bl	toCFA
	; call
	mov	r0, r9
	ldmfd	[r8]!, r9
	blx	r0

	b	@@interp_loop

@@not_in_dict:
	bl	DROP ; found ptr (zero)

	bl	OVER ; word ptr
	bl	OVER ; word len
	bl	NUMBER
	cmp	r9, 0
	bne	@@not_number

	bl	DROP ; uncoverted chars (zero)
	bl	NIP ; word ptr
	bl	NIP ; word len
	b	@@interp_loop

@@not_number:
	bl	DROP
	bl	DROP

	bl	TYPE
	bl	LIT
	dd	'?'
	bl	EMIT
	b	@@interp_loop

.pool

; Dictionary:


name_DROP:
	dd	0 ; link
	db	4,'drop' ; name
	.align	4
DROP:
	ldmfd	[r8]!, r9
	bx	lr

name_SWAP:
	dd	name_DROP ; link
	db	4,'swap' ; name
	.align	4
SWAP:
	swp	r9, r9, [r8]
	bx	lr

name_DUP:
	dd	name_SWAP ; link
	db	3,'dup' ; name
	.align	4
DUP:
	stmfd	[r8]!, r9
	bx	lr

name_OVER:
	dd	name_DUP ; link
	db	4,'over' ; name
	.align	4
OVER:
	stmfd	[r8]!, r9
	ldr	r9, [r8, 4]
	bx	lr

name_NIP:
	dd	name_OVER ; link
	db	3,'nip' ; name
	.align	4
NIP:
	add	r8, r8, 4
	bx	lr

name_plus:
	dd	name_NIP ; link
	db	1,'+' ; name
	.align	4
plus:
	ldmfd	[r8]!, r0
	add	r9, r0, r9
	bx	lr

name_minus:
	dd	name_plus ; link
	db	1,'-' ; name
	.align	4
minus:
	ldmfd	[r8]!, r0
	sub	r9, r0, r9
	bx	lr

name_times:
	dd	name_minus ; link
	db	1,'*' ; name
	.align	4
times:
	ldmfd	[r8]!, r0
	mul	r9, r0, r9
	bx	lr

name_divide:
	dd	name_times ; link
	db	1,'/' ; name
	.align	4
divide:
	push	lr
	ldmfd	[r8]!, r0
	mov	r1, r9
	bl	f_arm9_divide_32
	mov	r9, r0
	pop	lr
	bx	lr

name_EXIT:
	dd	name_divide ; link
	db	4,'exit' ; name
	.align	4
EXIT:
	pop	lr
	bx	lr

name_LIT:
	dd	name_EXIT ; link
	db	3,'lit' ; name
	.align	4
LIT:
	stmfd	[r8]!, r9
	ldmia	[lr]!, r9
	bx	lr

name_store:
	dd	name_LIT ; link
	db	1,'!' ; name
	.align	4
store:
	ldmfd	[r8]!, r0 ; data to store
	str	r0, [r9]
	ldmfd	[r8]!, r9
	bx	lr

name_fetch:
	dd	name_store ; link
	db	1,'@' ; name
	.align	4
fetch:
	ldr	r9, [r9]
	bx	lr

name_STATE:
	dd	name_fetch ; link
	db	5,'state' ; name
	.align	4
STATE:
	stmfd	[r8]!, r9
	add	r9, =var_STATE
	bx	lr
var_STATE:
	dd	0

name_HERE:
	dd	name_STATE ; link
	db	4,'here' ; name
	.align	4
HERE:
	stmfd	[r8]!, r9
	add	r9, =var_HERE
	bx	lr
var_HERE:
	dd	0 ; TODO

name_LATEST:
	dd	name_HERE ; link
	db	6,'latest' ; name
	.align	4
LATEST:
	stmfd	[r8]!, r9
	add	r9, =var_LATEST
	bx	lr
var_LATEST:
	dd	name_FIND ; TODO

name_rpush:
	dd	name_LATEST ; link
	db	2,'>r' ; name
	.align	4
rpush:
	push	r9
	ldmfd	[r8]!, r9
	bx	lr

name_rpop:
	dd	name_rpush ; link
	db	2,'r>' ; name
	.align	4
rpop:
	stmfd	[r8]!, r9
	pop	r9
	bx	lr

name_KEY:
	dd	name_rpop ; link
	db	3,'key' ; name
	.align	4
KEY:
	; TODO: add input buffer
	push	lr
	bl	f_key
	stmfd	[r8]!, r9
	mov	r9, r0
	pop	lr
	bx	lr

f_key:
	push	r4,lr
	bl	f_await_keypress
	mov	r4, r0
	bl	f_print_char
	mov	r0, r4
	pop	r4,lr
	bx	lr
	

name_EMIT:
	dd	name_KEY ; link
	db	4,'emit' ; name
	.align	4
EMIT:
	push	lr
	mov	r0, r9
	bl	f_print_char
	ldmfd	[r8]!, r9
	pop	lr
	bx	lr

name_WORD:
	dd	name_EMIT ; link
	db	4,'word' ; name
	.align	4
WORD:
	push	r4,lr

@@find_non_blank:
	bl	f_key
	cmp	r0, ' '
	cmpne	r0, 10 ; newline
	beq	@@find_non_blank ; keep searching

	add	r4, =@@word_buf
@@append_loop:
	strb	r0, [r4]
	add	r4, r4, 1
	bl	f_key
	cmp	r0, ' '
	cmpne	r0, 10 ; newline
	bne	@@append_loop ; keep appending

	add	r0, =@@word_buf
	stmfd	[r8]!, r0,r9
	sub	r9, r4, r0 ; word length

	pop	r4,lr
	bx	lr

@@word_buf:
	defs	32

; print a string
name_TYPE:
	dd	name_WORD ; link
	db	4,'type' ; name
	.align	4
TYPE:
	push	lr
	mov	r1, r9
	ldmfd	[r8]!, r0,r9
	bl	f_print_string
	pop	lr
	bx	lr

; print number in hex
name_Xdot:
	dd	name_TYPE ; link
	db	2,'x.' ; name
	.align	4
Xdot:
	push	lr
	mov	r0, r9
	bl	f_print_u32_hex
	ldmfd	[r8]!, r9
	pop	lr
	bx	lr

name_NUMBER:
	dd	name_Xdot ; link
	db	6,'number' ; name
	.align	4
NUMBER:
	push	r4
	; TODO: support fixed point fractions (16.16)

	ldmfd	[r8]!, r0 ; char ptr (don't move stack)
	mov	r1, 10   ; base
	mov	r2, 0    ; value

	cmp	r9, 0 ; chars remaining
	beq	@@done

	ldrb	r4, [r0] ; negative sign or hex prefix? (can't use both)
	cmp	r4, '$'
	moveq	r1, 16
	cmpne	r4, '-'
	addeq	r0, r0, 1 ; either - or $ -- move ahead 1 char
	subeqs	r9, r9, 1
	beq	@@done

@@parse_loop:
	ldrb	r3, [r0] ; char
	sub	r3, r3, '0'
	cmp	r3, 9
	bls	@@not_letter
	; TODO: support lowercase letters
	cmp	r3, ('A' - '0')
	blo	@@done ; not valid (between '9' and 'A')
	subs	r3, r3, ('A' - '9' - 1)
@@not_letter:
	cmp	r3, r1
	bhs	@@done   ; digit out of range
	mla	r2, r2, r1, r3

	add	r0, r0, 1
	subs	r9, r9, 1
	bne	@@parse_loop

@@done:
	cmp	r4, '-'
	rsbeq	r2, r2, 0 ; negate

	stmfd	[r8]!, r2
	pop	r4
	bx	lr

name_FIND:
	dd	name_NUMBER ; link
	db	4,'find' ; name
	.align	4
FIND:
	push	r4
	ldmfd	[r8]!, r0 ; string ptr
	mov	r1, r9    ; string len
	ldr	r9, [var_LATEST] ; header ptr

@@search_loop:
	cmp	r9, 0
	beq	@@done

	ldrb	r2, [r9, 4] ; word len
	mov	r2, r2, LSL#(32 - word_length_bits - 1) ; include hidden flag
	mov	r2, r2, LSR#(32 - word_length_bits - 1)
	cmp	r2, r1
	bne	@@search_next ; length not equal, or hidden flag set

	; strcmp (TODO: optimize!)
	sub	r2, r2, 1
@@strcmp_loop:
	ldrb	r3, [r0, r2]
	add	r4, r2, 5 ; word name offset
	ldrb	r4, [r9, r4]
	cmp	r3, r4
	bne	@@search_next
	subs	r2, r2, 1
	bge	@@strcmp_loop

	; matching!
@@done:
	pop	r4
	bx	lr

@@search_next:
	ldr	r9, [r9]
	b	@@search_loop

name_toCFA:
	dd	name_FIND ; link
	db	4,'>cfa' ; name
	.align	4
toCFA:
	add	r9, r9, 4
	ldrb	r0, [r9] ; word length / flags
	mov	r0, r0, LSL#(32 - word_length_bits)
	mov	r0, r0, LSR#(32 - word_length_bits)
	add	r9, r9, r0  ; skip name
	add	r9, r9, 4   ; skip length, padding
	bic	r9, r9, 0x3 ; align
	bx	lr
