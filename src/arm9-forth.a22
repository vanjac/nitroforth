data_stack_top = (dtcm_loc + 0x2000)

word_length_mask = 0x1F
word_length_bits = 5
word_hidden_flag = 0x20
word_immediate_flag = 0x80

; dsForth is subroutine-threaded

; r0:	Scratch
; r1:	Scratch
; r2:	Scratch
; r3:	Scratch
; r4:	Callee save
; r5:	Callee save
; r6:	Callee save
; r7:	Callee save
; r8:	Data Stack Pointer
; r9:	Top Data Stack Value
; r10:	Constant 0x04000000
; r11:	?
; r12:	Scratch(?)
; r13:	Return Stack Pointer
; r14:	Link Register
; r15:	Program Counter

var_return_stack_top:
	dd	0

start_forth:
	push	r4

	ldr	r8, =data_stack_top ; Set the data stack pointer
	str	sp, [var_return_stack_top] ; Store the return stack top

@@interp_loop:

	; check for errors
	ldr	r4, =data_stack_top
	cmp	r8, r4
	bls	@@no_data_underflow
	bl	f_print_string_inline
		db	10,'!! Data Underflow !!',10,0
		.align	4
	ldr	r8, =data_stack_top ; reset data stack
@@no_data_underflow:
	ldr	r4, [var_return_stack_top]
	cmp	sp, r4
	bls	@@no_return_underflow
	bl	f_print_string_inline
		db	10,'!! Return Underflow !!',10,0
		.align	4
@@no_return_underflow:
	cmp	sp, r4
	bhs	@@return_empty
	bl	f_print_string_inline
		db	10,'!! Return Not Empty !!',10,0
		.align	4
@@return_empty:
	mov	sp, r4 ; reset return stack always
	; end error check

	bl	WORD
	bl	OVER ; word ptr
	bl	OVER ; word len
	bl	FIND
	cmp	r9, 0
	beq	@@not_in_dict

	bl	NIP ; word ptr
	bl	NIP ; word len
	ldrb	r4, [r9, 4]
	bl	toCFA
	tst	r4, word_immediate_flag
	bne	@@execute
	ldr	r0, [var_STATE]
	cmp	r0, 0
	beq	@@execute

	; compile word
	bl	CALLcomma
	b	@@interp_loop

@@execute:
	; call
	mov	r0, r9
	ldmfd	[r8]!, r9 ; drop
	blx	r0

	b	@@interp_loop

@@not_in_dict:
	bl	DROP ; found ptr (zero)

	bl	OVER ; word ptr
	bl	OVER ; word len
	bl	NUMBER
	cmp	r9, 0
	bne	@@not_number

	bl	DROP ; uncoverted chars (zero)
	bl	NIP ; word ptr
	bl	NIP ; word len

	ldr	r0, [var_STATE]
	cmp	r0, 0
	beq	@@interp_loop

	; compile literal
	bl	LITERAL

	b	@@interp_loop

@@not_number:
	bl	DROP
	bl	DROP

	bl	TYPE
	bl	LIT
		dd	'?'
	bl	EMIT
	bl	LIT
		dd	10 ; newline
	bl	EMIT
	b	@@interp_loop

; Dictionary:


; ( a -- )
name_DROP:
	dd	0 ; link
	db	4,'drop' ; name
	.align	4
DROP:
	ldmfd	[r8]!, r9
	bx	lr

; ( a b -- b a )
name_SWAP:
	dd	name_DROP ; link
	db	4,'swap' ; name
	.align	4
SWAP:
	swp	r9, r9, [r8]
	bx	lr

; ( a -- a a )
name_DUP:
	dd	name_SWAP ; link
	db	3,'dup' ; name
	.align	4
DUP:
	stmfd	[r8]!, r9
	bx	lr

; ( a b -- a b a )
name_OVER:
	dd	name_DUP ; link
	db	4,'over' ; name
	.align	4
OVER:
	stmfd	[r8]!, r9
	ldr	r9, [r8, 4]
	bx	lr

; ( a b -- b )
name_NIP:
	dd	name_OVER ; link
	db	3,'nip' ; name
	.align	4
NIP:
	add	r8, r8, 4
	bx	lr

; ( a b -- a+b )
name_plus:
	dd	name_NIP ; link
	db	1,'+' ; name
	.align	4
plus:
	ldmfd	[r8]!, r0
	add	r9, r0, r9
	bx	lr

; ( a b -- a-b )
name_minus:
	dd	name_plus ; link
	db	1,'-' ; name
	.align	4
minus:
	ldmfd	[r8]!, r0
	sub	r9, r0, r9
	bx	lr

; ( a b -- a*b )
name_times:
	dd	name_minus ; link
	db	1,'*' ; name
	.align	4
times:
	ldmfd	[r8]!, r0
	mul	r9, r0, r9
	bx	lr

; TODO: replace with /MOD
; ( a b -- a/b )
name_divide:
	dd	name_times ; link
	db	1,'/' ; name
	.align	4
divide:
	push	lr
	ldmfd	[r8]!, r0
	mov	r1, r9
	bl	f_arm9_divide_32
	mov	r9, r0
	pop	lr
	bx	lr

; ( a -- -a )
name_NEGATE:
	dd	name_divide ; link
	db	6,'negate' ; name
	.align	4
NEGATE:
	rsb	r9, r9, 0
	bx	lr

; ( a b -- a&b )
name_AND:
	dd	name_NEGATE ; link
	db	3,'and' ; name
	.align	4
AND:
	ldmfd	[r8]!, r0
	and	r9, r0, r9
	bx	lr

; ( a b -- a|b )
name_OR:
	dd	name_AND ; link
	db	2,'or' ; name
	.align	4
OR:
	ldmfd	[r8]!, r0
	orr	r9, r0, r9
	bx	lr

; ( a b -- a^b )
name_XOR:
	dd	name_OR ; link
	db	3,'xor' ; name
	.align	4
XOR:
	ldmfd	[r8]!, r0
	eor	r9, r0, r9
	bx	lr

; ( a -- ~a )
name_INVERT:
	dd	name_XOR ; link
	db	6,'invert' ; name
	.align	4
INVERT:
	mvn	r9, r9
	bx	lr

; ( a b -- a>>b )
name_LSHIFT:
	dd	name_INVERT ; link
	db	6,'lshift' ; name
	.align	4
LSHIFT:
	ldmfd	[r8]!, r0
	mov	r9, r0, LSL r9
	bx	lr

; ( a b -- a>>b )
name_RSHIFT:
	dd	name_LSHIFT ; link
	db	6,'rshift' ; name
	.align	4
RSHIFT:
	ldmfd	[r8]!, r0
	mov	r9, r0, LSR r9
	bx	lr

; ( -- )
name_EXIT:
	dd	name_RSHIFT ; link
	db	4,'exit' ; name
	.align	4
EXIT:
	pop	lr
	bx	lr

; ( -- value )
name_LIT:
	dd	name_EXIT ; link
	db	3,'lit' ; name
	.align	4
LIT:
	stmfd	[r8]!, r9
	ldmia	[lr]!, r9
	bx	lr

; ( data addr -- )
name_store:
	dd	name_LIT ; link
	db	1,'!' ; name
	.align	4
store:
	ldmfd	[r8]!, r0 ; data to store
	str	r0, [r9]
	ldmfd	[r8]!, r9
	bx	lr

; ( addr -- data )
name_fetch:
	dd	name_store ; link
	db	1,'@' ; name
	.align	4
fetch:
	ldr	r9, [r9]
	bx	lr

; ( data addr -- )
name_Cstore:
	dd	name_fetch ; link
	db	2,'c!' ; name
	.align	4
Cstore:
	ldmfd	[r8]!, r0 ; data to store
	strb	r0, [r9]
	ldmfd	[r8]!, r9
	bx	lr

; ( addr -- data )
name_Cfetch:
	dd	name_Cstore ; link
	db	2,'c@' ; name
	.align	4
Cfetch:
	ldrb	r9, [r9]
	bx	lr

name_STATE:
	dd	name_Cfetch ; link
	db	5,'state' ; name
	.align	4
STATE:
	stmfd	[r8]!, r9
	add	r9, =var_STATE
	bx	lr
var_STATE:
	dd	0

name_HERE:
	dd	name_STATE ; link
	db	4,'here' ; name
	.align	4
HERE:
	stmfd	[r8]!, r9
	add	r9, =var_HERE
	bx	lr
var_HERE:
	dd	arm9_end ; TODO

name_LATEST:
	dd	name_HERE ; link
	db	6,'latest' ; name
	.align	4
LATEST:
	stmfd	[r8]!, r9
	add	r9, =var_LATEST
	bx	lr
var_LATEST:
	dd	latest_word ; TODO

name_rpush:
	dd	name_LATEST ; link
	db	2,'>r' ; name
	.align	4
rpush:
	push	r9
	ldmfd	[r8]!, r9
	bx	lr

name_rpop:
	dd	name_rpush ; link
	db	2,'r>' ; name
	.align	4
rpop:
	stmfd	[r8]!, r9
	pop	r9
	bx	lr

; ( -- char )
name_KEY:
	dd	name_rpop ; link
	db	3,'key' ; name
	.align	4
KEY:
	push	lr
	bl	f_key
	stmfd	[r8]!, r9
	mov	r9, r0
	pop	lr
	bx	lr

f_key:
	push	r4-r6,lr
	ldr	r5, [curkey]
	ldr	r1, [buftop]
	cmp	r5, r1
	bhs	@@get_more_input

@@get_buffered_input:
	ldrb	r0, [r5]
	add	r5, r5, 1
	str	r5, [curkey]

	pop	r4-r6,lr
	bx	lr

@@get_more_input:
	ldr	r5, =input_buffer ; curkey
	mov	r6, r5 ; buftop
@@lineread_loop:
	bl	f_await_keypress
	cmp	r0, 8 ; backspace
	beq	@@backspace
	; add character
	strb	r0, [r6]
	add	r6, r6, 1
@@print_char:
	mov	r4, r0
	orr	r0, r0, 0x1000 ; palette 1
	bl	f_print_char
	cmp	r4, 10 ; newline
	bne	@@lineread_loop

	str	r6, [buftop]
	b	@@get_buffered_input

@@backspace:
	cmp	r6, r5
	bls	@@lineread_loop ; can't backspace
	sub	r6, r6, 1
	b	@@print_char

curkey:
	dd	input_buffer
buftop:
	dd	init_end

; ( char -- )
name_EMIT:
	dd	name_KEY ; link
	db	4,'emit' ; name
	.align	4
EMIT:
	push	lr
	mov	r0, r9
	bl	f_print_char
	ldmfd	[r8]!, r9
	pop	lr
	bx	lr

; ( -- addr len )
name_WORD:
	dd	name_EMIT ; link
	db	4,'word' ; name
	.align	4
WORD:
	push	r4,lr

@@find_non_blank:
	bl	f_key
	cmp	r0, ' '
	cmpne	r0, 10 ; newline
	beq	@@find_non_blank ; keep searching

	add	r4, =@@word_buf
@@append_loop:
	strb	r0, [r4]
	add	r4, r4, 1
	bl	f_key
	cmp	r0, ' '
	cmpne	r0, 10 ; newline
	bne	@@append_loop ; keep appending

	add	r0, =@@word_buf
	stmfd	[r8]!, r0,r9
	sub	r9, r4, r0 ; word length

	pop	r4,lr
	bx	lr

@@word_buf:
	defs	32

; print a string
; ( addr len -- )
name_TYPE:
	dd	name_WORD ; link
	db	4,'type' ; name
	.align	4
TYPE:
	push	lr
	mov	r1, r9
	ldmfd	[r8]!, r0,r9
	bl	f_print_string
	pop	lr
	bx	lr

; print number in hex
; ( num -- )
name_Xdot:
	dd	name_TYPE ; link
	db	2,'x.' ; name
	.align	4
Xdot:
	push	lr
	mov	r0, r9
	bl	f_print_u32_hex
	ldmfd	[r8]!, r9
	pop	lr
	bx	lr

; ( addr len -- value unparsed )
name_NUMBER:
	dd	name_Xdot ; link
	db	6,'number' ; name
	.align	4
NUMBER:
	push	r4
	; TODO: support fixed point fractions (16.16)

	ldmfd	[r8]!, r0 ; char ptr (don't move stack)
	mov	r1, 10   ; base
	mov	r2, 0    ; value

	cmp	r9, 0 ; chars remaining
	beq	@@done

	ldrb	r4, [r0] ; negative sign or hex prefix? (can't use both)
	cmp	r4, '$'
	moveq	r1, 16
	cmpne	r4, '-'
	addeq	r0, r0, 1 ; either - or $ -- move ahead 1 char
	subeqs	r9, r9, 1
	beq	@@done

@@parse_loop:
	ldrb	r3, [r0] ; char
	sub	r3, r3, '0'
	cmp	r3, 9
	bls	@@not_letter
	; TODO: support lowercase letters
	cmp	r3, ('A' - '0')
	blo	@@done ; not valid (between '9' and 'A')
	subs	r3, r3, ('A' - '9' - 1)
@@not_letter:
	cmp	r3, r1
	bhs	@@done   ; digit out of range
	mla	r2, r2, r1, r3

	add	r0, r0, 1
	subs	r9, r9, 1
	bne	@@parse_loop

@@done:
	cmp	r4, '-'
	rsbeq	r2, r2, 0 ; negate

	stmfd	[r8]!, r2
	pop	r4
	bx	lr

; ( addr len -- header )
name_FIND:
	dd	name_NUMBER ; link
	db	4,'find' ; name
	.align	4
FIND:
	push	r4
	ldmfd	[r8]!, r0 ; string ptr
	mov	r1, r9    ; string len
	ldr	r9, [var_LATEST] ; header ptr

@@search_loop:
	cmp	r9, 0
	beq	@@done

	ldrb	r2, [r9, 4] ; word len
	mov	r2, r2, LSL#(32 - word_length_bits - 1) ; include hidden flag
	mov	r2, r2, LSR#(32 - word_length_bits - 1)
	cmp	r2, r1
	bne	@@search_next ; length not equal, or hidden flag set

	; strcmp (TODO: optimize!)
	sub	r2, r2, 1
@@strcmp_loop:
	ldrb	r3, [r0, r2]
	add	r4, r2, 5 ; word name offset
	ldrb	r4, [r9, r4]
	cmp	r3, r4
	bne	@@search_next
	subs	r2, r2, 1
	bge	@@strcmp_loop

	; matching!
@@done:
	pop	r4
	bx	lr

@@search_next:
	ldr	r9, [r9]
	b	@@search_loop

; ( header -- code )
name_toCFA:
	dd	name_FIND ; link
	db	4,'>cfa' ; name
	.align	4
toCFA:
	add	r9, r9, 4
	ldrb	r0, [r9] ; word length / flags
	mov	r0, r0, LSL#(32 - word_length_bits)
	mov	r0, r0, LSR#(32 - word_length_bits)
	add	r9, r9, r0  ; skip name
	add	r9, r9, 4   ; skip length, padding
	bic	r9, r9, 0x3 ; align
	bx	lr

; ( addr len -- )
name_CREATE:
	dd	name_toCFA ; link
	db	6,'create' ; name
	.align	4
CREATE:
	push	r4
	mov	r0, r9 ; length
	ldmfd	[r8]!, r1,r9 ; str

	ldr	r2, [var_HERE]
	ldr	r3, [var_LATEST]
	str	r2, [var_LATEST] ; update latest

	str	r3, [r2] ; link pointer
	strb	r0, [r2, 4] ; length
	add	r2, 5
	mov	r4, 0
@@copy_word:
	ldrb	r3, [r1, r4]
	strb	r3, [r2, r4]
	add	r4, r4, 1
	subs	r0, r0, 1
	bgt	@@copy_word

	add	r2, r2, r4
	add	r2, r2, 3 ; padding
	bic	r2, r2, 0x3 ; align
	str	r2, [var_HERE]

	pop	r4
	bx	lr

; ( data -- )
name_comma:
	dd	name_CREATE ; link
	db	1,',' ; name
	.align	4
comma:
	ldr	r0, [var_HERE]
	stmia	[r0]!, r9
	str	r0, [var_HERE]
	ldmfd	[r8]!, r9
	bx	lr

name_lbrac:
	dd	name_comma ; link
	db	(1 or word_immediate_flag),'[' ; name
	.align	4
lbrac:
	mov	r0, 0
	str	r0, [var_STATE]
	bx	lr

name_rbrac:
	dd	name_lbrac ; link
	db	1,']' ; name
	.align	4
rbrac:
	mov	r0, 1
	str	r0, [var_STATE]
	bx	lr

; ( addr -- )
name_HIDDEN:
	dd	name_rbrac
	db	6,'hidden' ; name
	.align	4
HIDDEN:
	ldrb	r0, [r9, 4]
	eor	r0, r0, word_hidden_flag
	strb	r0, [r9, 4]
	ldmfd	[r8]!, r9
	bx	lr

name_colon:
	dd	name_HIDDEN ; link
	db	1,':' ; name
	.align	4
colon:
	push	lr
	bl	WORD
	bl	CREATE
	bl	LIT
		dd	0xE92D4000 ; 'push lr' instruction
	bl	COMMA
	bl	LATEST
	bl	fetch
	bl	HIDDEN
	bl	rbrac
	bl	EXIT

; ( cond -- )
name_0BRANCH:
	dd	name_colon ; link
	db	7,'0branch' ; name
	.align	4
0BRANCH:
	cmp	r9, 0
	ldreq	r0, [lr] ; offset
	addeq	lr, lr, r0
	addne	lr, lr, 4
	ldmfd	[r8]!, r9
	bx	lr

; assemble a call ("bl") instruction and write to HERE
; ( code -- )
name_CALLcomma:
	dd	name_0BRANCH ; link
	db	5,'call,' ; name
	.align	4
CALLcomma:
	ldr	r0, [var_HERE]
	sub	r1, r9, r0
	sub	r1, r1, 8
	mov	r2, 0xEB000000
	mov	r1, r1, LSL#6
	orr	r1, r2, r1, LSR#8
	stmia	[r0]!, r1
	str	r0, [var_HERE]
	ldmfd	[r8]!, r9
	bx	lr

; add a LIT instruction
; ( value -- )
name_LITERAL:
	dd	name_CALLcomma ; link
	db	7,'literal' ; name
	.align	4
LITERAL:
	; TODO: optimize small literals
	push	lr
	bl	LIT
		dd	LIT
	bl	CALLcomma
	bl	COMMA ; add value
	pop	lr
	bx	lr

name_semicolon:
	dd	name_LITERAL ; link
	db	(1 or word_immediate_flag),';' ; name
	.align	4
semicolon:
	push	lr
	bl	LIT
		dd	EXIT
	bl	CALLcomma
	bl	LATEST
	bl	fetch
	bl	HIDDEN
	bl	lbrac
	bl	EXIT

name_comment:
	dd	name_semicolon ; link
	db	(1 or word_immediate_flag),'(' ; name
	.align	4
comment:
	push	r4,lr
	mov	r4, 1 ; depth
@@loop:
	bl	f_key
	cmp	r0, '('
	addeq	r4, r4, 1
	cmp	r0, ')'
	subeq	r4, r4, 1
	cmp	r4, 0
	bne	@@loop
	pop	r4,lr
	bx	lr

latest_word = name_comment
.pool
